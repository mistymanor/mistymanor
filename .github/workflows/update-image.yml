name: Update Website Image

on:
  workflow_dispatch:
    inputs:
      source_type:
        description: 'Image source'
        required: true
        type: choice
        options:
          - 'existing_image'
          - 'url_upload'
        default: 'existing_image'
      target_image:
        description: 'Select image to update'
        required: true
        type: choice
        options:
          - 'Homepage Main Banner (images/MMBanner.jpeg)'
          - 'Trail Rides Banner (images/MMTrailBanner.jpeg)'
          - 'Lessons Banner (images/MMLessonsBanner.jpeg)'
          - 'Volunteering Banner (images/MMVolunteerBanner.jpeg)'
          - 'Meet Our Horses Banner (images/MMHorsesBanner.jpeg)'
          - 'Contact Page Banner (images/MMContactBanner.jpeg)'
      source_image:
        description: 'Enter source image name without extension (e.g., "MMBanner" for images/MMBanner.jpeg)'
        required: false
        type: string
      image_url:
        description: 'URL to image (if uploading new)'
        required: false
        type: string

jobs:
  update-image:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Install image processing tools
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick
          
      - name: Set target image path
        id: set-target
        run: |
          TARGET_DESC="${{ github.event.inputs.target_image }}"
          
          # Extract the path from the description (format: "Description (path)")
          TARGET_PATH=$(echo "$TARGET_DESC" | sed -E 's/.*\((.*)\).*/\1/')
          
          if [ -z "$TARGET_PATH" ]; then
            echo "Error: Could not extract target image path from '$TARGET_DESC'"
            exit 1
          fi
          
          echo "TARGET_PATH=$TARGET_PATH" >> $GITHUB_ENV
          echo "Target image to update: $TARGET_PATH"

      - name: Process source image
        id: process-source
        run: |
          mkdir -p temp_images
          
          # Handle different source types
          if [ "${{ github.event.inputs.source_type }}" == "existing_image" ]; then
            SOURCE_NAME="${{ github.event.inputs.source_image }}"
            
            if [ -z "$SOURCE_NAME" ]; then
              echo "Error: No source image name provided"
              exit 1
            fi
            
            echo "Looking for image with name: $SOURCE_NAME"
            
            # Find matching files in the images directory with any extension
            # Look for common image extensions jpg, jpeg, png, gif, webp
            MATCHES=$(find images -type f -name "$SOURCE_NAME.*" | grep -E '\.jpg$|\.jpeg$|\.png$|\.gif$|\.webp$')
            MATCH_COUNT=$(echo "$MATCHES" | grep -v "^$" | wc -l)
            
            if [ "$MATCH_COUNT" -eq 0 ]; then
              echo "Error: No matching images found for '$SOURCE_NAME'"
              echo "Available images:"
              find images -type f | grep -E '\.jpg$|\.jpeg$|\.png$|\.gif$|\.webp$' | xargs basename | sort
              exit 1
            elif [ "$MATCH_COUNT" -gt 1 ]; then
              echo "Warning: Multiple matches found for '$SOURCE_NAME'. Using the first match."
              echo "Matches:"
              echo "$MATCHES"
              # Use the first match
              SOURCE_PATH=$(echo "$MATCHES" | head -n 1)
            else
              SOURCE_PATH="$MATCHES"
            fi
            
            # Copy the existing image to temp directory
            cp "$SOURCE_PATH" temp_images/source_image.jpg
            echo "Using existing image: $SOURCE_PATH"
            
          elif [ "${{ github.event.inputs.source_type }}" == "url_upload" ]; then
            # Download image from URL
            IMAGE_URL="${{ github.event.inputs.image_url }}"
            
            if [ -z "$IMAGE_URL" ]; then
              echo "Error: No image URL provided"
              exit 1
            fi
            
            echo "Downloading image from URL: $IMAGE_URL"
            curl -L "$IMAGE_URL" -o temp_images/source_image.jpg
            
            if [ $? -ne 0 ]; then
              echo "Error: Failed to download image from URL"
              exit 1
            fi
          else
            echo "Error: Invalid source type"
            exit 1
          fi
          
          # Validate the image
          file_type=$(file -b --mime-type temp_images/source_image.jpg)
          if [[ $file_type != image/* ]]; then
            echo "Error: File is not a valid image (detected type: $file_type)"
            exit 1
          fi
          
          # Get dimensions of target image to maintain aspect ratio
          if [ -f "$TARGET_PATH" ]; then
            TARGET_DIMENSIONS=$(identify -format "%wx%h" "$TARGET_PATH")
            echo "Target dimensions: $TARGET_DIMENSIONS"
            
            # Optimize and resize image to match target dimensions
            convert temp_images/source_image.jpg -resize "$TARGET_DIMENSIONS" -quality 85 temp_images/optimized_image.jpg
          else
            # If target doesn't exist yet, use standard optimizations
            convert temp_images/source_image.jpg -resize "1200x>" -quality 85 temp_images/optimized_image.jpg
          fi
          
          echo "SOURCE_IMAGE=temp_images/optimized_image.jpg" >> $GITHUB_ENV

      - name: Update the image
        run: |
          # Make backup of original if it exists
          if [ -f "$TARGET_PATH" ]; then
            mkdir -p backups
            cp "$TARGET_PATH" "backups/$(basename "$TARGET_PATH").$(date +%Y%m%d%H%M%S).bak"
          fi
          
          # Ensure target directory exists
          mkdir -p $(dirname "$TARGET_PATH")
          
          # Replace image
          cp "$SOURCE_IMAGE" "$TARGET_PATH"
          
          echo "Successfully updated $TARGET_PATH"
      
      - name: Update configuration file
        run: |
          # If this is a new image that doesn't exist in the config yet, add it
          if ! grep -q "$TARGET_PATH" config/image-config.json; then
            # Extract filename without path and extension for a default description
            FILENAME=$(basename "$TARGET_PATH")
            DESCRIPTION="${FILENAME%.*} Image"
            
            # Add to both site_images and available_images
            NEW_ENTRY="{\"path\":\"$TARGET_PATH\",\"description\":\"$DESCRIPTION\",\"category\":\"Image\"}"
            
            # Use jq to modify the JSON file
            jq --arg entry "$NEW_ENTRY" '.site_images += [$entry | fromjson]' config/image-config.json > config/temp.json
            jq --arg entry "$NEW_ENTRY" '.available_images += [$entry | fromjson]' config/temp.json > config/image-config.json
            rm config/temp.json
            
            echo "Added new image to configuration: $TARGET_PATH"
          fi
      
      - name: Clean up
        run: |
          rm -rf temp_images
      
      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add "$TARGET_PATH"
          git add config/image-config.json
          
          # Only add backups directory if it exists
          if [ -d "backups" ]; then
            git add backups/
          fi
          
          TARGET_DESC="${{ github.event.inputs.target_image }}"
          SOURCE_TYPE="${{ github.event.inputs.source_type }}"
          
          if [ "$SOURCE_TYPE" == "existing_image" ]; then
            SOURCE_DESC="${{ github.event.inputs.source_image }}"
            COMMIT_MSG="Update image: $TARGET_DESC with $SOURCE_DESC"
          else
            COMMIT_MSG="Update image: $TARGET_DESC with uploaded image"
          fi
          
          git commit -m "$COMMIT_MSG"
          git push

